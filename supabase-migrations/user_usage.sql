-- Migration: Create user_usage table for tracking guest and authenticated user message limits
-- This table tracks usage for both guest users (guest_id) and authenticated users (user_id)

create table if not exists user_usage (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) on delete cascade,
  guest_id text,
  plan text default 'guest' check (plan in ('guest', 'free', 'pro')),
  messages_used int default 0 not null,
  deepsearch_used int default 0 not null,
  last_reset timestamptz default now() not null,
  created_at timestamptz default now() not null,
  updated_at timestamptz default now() not null,
  constraint user_or_guest_check check (
    (user_id is not null and guest_id is null) or
    (user_id is null and guest_id is not null)
  ),
  constraint unique_user_usage unique (user_id, guest_id)
);

-- Indexes for performance
create index if not exists idx_user_usage_user_id on user_usage(user_id) where user_id is not null;
create index if not exists idx_user_usage_guest_id on user_usage(guest_id) where guest_id is not null;
create index if not exists idx_user_usage_plan on user_usage(plan);
create index if not exists idx_user_usage_last_reset on user_usage(last_reset);

-- RLS Policies
alter table user_usage enable row level security;

-- Policy: Users can read their own usage
create policy "Users can read own usage"
  on user_usage
  for select
  using (auth.uid() = user_id);

-- Policy: Service role can manage all usage (for server-side operations)
-- Note: This requires service role key, which is only available server-side

-- Function to update updated_at timestamp
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Trigger to auto-update updated_at
create trigger update_user_usage_updated_at
  before update on user_usage
  for each row
  execute function update_updated_at_column();

